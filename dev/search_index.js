var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = WunDeeDB","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#WunDeeDB","page":"Home","title":"WunDeeDB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for WunDeeDB.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module supports bulk operations (insertions, deletions, and updates) with a hard limit of 1000 records per operation. In addition, the module supports the following numerical types for embedding data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Float16\nFloat32\nFloat64\nBigFloat\nInt8\nUInt8\nInt16\nUInt16\nInt32\nUInt32\nInt64\nUInt64\nInt128\nUInt128","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types are defined in the DATATYPEMAP and are used to correctly parse and manage the embedding vectors stored in the SQLite database. The constant BULK_LIMIT is set to 1000 to prevent overly large transactions during bulk operations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WunDeeDB]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"#WunDeeDB.bulk_delete_embedding-Tuple{SQLite.DB, String, Vector{<:AbstractString}}","page":"Home","title":"WunDeeDB.bulk_delete_embedding","text":"bulkdeleteembedding(db::SQLite.DB, collectionname::String, idtexts::Vector{<:AbstractString}) -> String\n\nDelete multiple embedding records from the specified collection (table) in an SQLite database.\n\nThis function removes rows from the table named collection_name where the id_text is one of the provided identifiers. It enforces a limit on the number of identifiers via the predefined constant BULK_LIMIT to prevent overly large transactions. If the number of identifiers exceeds BULK_LIMIT, an error is raised.\n\nThe deletion process is executed within an SQLite transaction to ensure atomicity. After the deletion, the function updates the associated metadata table (assumed to be named $(collection_name)_meta) by calling bulk_update_meta_delete, which subtracts the number of deleted rows from the stored metadata.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table from which embeddings are to be deleted.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings corresponding to the rows to delete.\n\nReturns\n\nA String with the value \"true\" if the deletion is successful.\n\nRaises\n\nAn error if the number of identifiers exceeds BULK_LIMIT.\nAny SQL errors encountered during the deletion or metadata update will propagate, causing the transaction to roll back.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") ids = [\"id1\", \"id2\", \"id3\"] result = bulkdeleteembedding(db, \"embeddings\", ids) println(result)  # Should print \"true\" if the deletion and metadata update are successful.\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_delete_embedding-Tuple{String, String, Vector{<:AbstractString}}","page":"Home","title":"WunDeeDB.bulk_delete_embedding","text":"bulkdeleteembedding(dbpath::String, collectionname::String, id_texts::Vector{<:AbstractString}) -> Union{String}\n\nA convenience wrapper for deleting multiple embedding records from an SQLite database using a database file path.\n\nThis function opens the SQLite database located at dbpath, calls the primary bulkdelete_embedding function to remove the specified rows from the given collection (table), and then ensures that the database connection is properly closed. If an error occurs during the deletion or metadata update, a descriptive error message is returned as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table from which embeddings are to be deleted.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings corresponding to the rows to delete.\n\nReturns\n\nOn success: A String with the value \"true\" indicating the deletion was successful.\nOn error: A String containing a descriptive error message.\n\nExample\n\n```juila result = bulkdeleteembedding(\"mydatabase.sqlite\", \"embeddings\", [\"id1\", \"id2\", \"id3\"]) if startswith(result, \"Error:\")     println(\"Bulk delete failed: \", result) else     println(\"Bulk delete successful: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_get_embedding-Tuple{SQLite.DB, String, Vector{<:AbstractString}}","page":"Home","title":"WunDeeDB.bulk_get_embedding","text":"bulkgetembedding(db::SQLite.DB, collectionname::String, idtexts::Vector{<:AbstractString}) -> Dict{String,Any}\n\nRetrieve embeddings in bulk from the specified collection (table) in an SQLite database, based on a vector of identifier strings.\n\nThis function first checks that the number of identifiers does not exceed a predefined bulk limit (BULK_LIMIT). It then constructs an SQL query using parameterized placeholders to select rows from the table collection_name where the id_text is one of the provided identifiers. For each returned row, it:\n\nRetrieves the id_text, JSON-encoded embedding (embedding_json), and data_type.\nUses the helper function parse_data_type to determine the correct type for the embedding.\nParses the JSON string into a vector using JSON3.read.\nInserts the resulting embedding vector into a dictionary with the corresponding id_text as the key.\n\nArguments\n\ndb::SQLite.DB: An active SQLite database connection.\ncollection_name::String: The name of the table (collection) to query.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings for which embeddings should be fetched.\n\nReturns\n\nA Dict{String,Any} mapping each id_text (as a String) to its corresponding embedding vector.\n\nRaises\n\nThrows an error if the number of identifiers exceeds the limit specified by BULK_LIMIT.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") ids = [\"id1\", \"id2\", \"id3\"] embeddings = bulkgetembedding(db, \"embeddings\", ids) for (id, emb) in embeddings     println(\"ID: \", id, \" -> Embedding: \", emb) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_get_embedding-Tuple{String, String, Vector{<:AbstractString}}","page":"Home","title":"WunDeeDB.bulk_get_embedding","text":"bulkgetembedding(dbpath::String, collectionname::String, id_texts::Vector{<:AbstractString}) -> Union{Dict{String,Any}, String}\n\nA convenience wrapper for bulk fetching embeddings from an SQLite database by specifying the database file path.\n\nThis function opens the SQLite database located at dbpath and calls the primary bulkgetembedding function to retrieve embeddings for the provided idtexts. The function ensures that the database connection is closed after the operation, even if an error occurs. In case of an error during execution, a descriptive error message is returned as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table (collection) to query.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings for which embeddings should be fetched.\n\nReturns\n\nOn success: A Dict{String,Any} mapping each id_text to its corresponding embedding vector.\nOn error: A String containing an error message.\n\nExample\n\n```julia ids = [\"id1\", \"id2\", \"id3\"] result = bulkgetembedding(\"mydatabase.sqlite\", \"embeddings\", ids) if isa(result, String)     println(\"Error occurred: \", result) else     for (id, emb) in result         println(\"ID: \", id, \" -> Embedding: \", emb)     end end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_insert_embedding-Tuple{SQLite.DB, String, Vector{<:AbstractString}, Vector{<:AbstractVector{<:Number}}}","page":"Home","title":"WunDeeDB.bulk_insert_embedding","text":"bulkinsertembedding(db::SQLite.DB, collectionname::String,                              idtexts::Vector{<:AbstractString}, embeddings::Vector{<:AbstractVector{<:Number}};                             data_type::Union{Nothing,String}=nothing) -> String\n\nBulk insert multiple embedding records into a specified collection (table) in an SQLite database.\n\nThis function performs several validation and insertion steps:\n\nValidation:\nChecks that the number of identifiers (in id_texts) does not exceed a predefined limit (BULK_LIMIT).\nVerifies that the number of embedding vectors matches the number of IDs.\nEnsures that all embedding vectors have the same length.\nIf data_type is not provided, it infers the data type from the first embedding vector using infer_data_type.\nParameter Preparation:\nConstructs a list of tuples, each containing:\nThe identifier (converted to a string).\nThe JSON-encoded embedding vector (using JSON3.write).\nThe determined data_type.\nInsertion Transaction:\nExecutes an INSERT statement for each record within a single SQLite transaction.\nAfter all records are inserted, updates the associated metadata table (assumed to be named $(collection_name)_meta) via update_meta_bulk to reflect the new embedding dimension and row count.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table where embeddings are stored.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings for the new records.\nembeddings::Vector{<:AbstractVector{<:Number}}: A vector of embedding vectors to be inserted. All embeddings must be of the same length.\ndata_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If omitted, the data type is inferred from the first embedding.\n\nReturns\n\nA String with the value \"true\" if the bulk insertion is successful.\n\nRaises\n\nAn error if the number of identifiers exceeds BULK_LIMIT.\nAn error if the number of embeddings does not match the number of IDs.\nAn error if the embedding vectors do not all have the same length.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") ids = [\"id1\", \"id2\", \"id3\"] embs = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]] result = bulkinsertembedding(db, \"embeddings\", ids, embs) println(\"Bulk insert result: \", result)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_insert_embedding-Tuple{String, String, Vector{<:AbstractString}, Vector{<:AbstractVector{<:Number}}}","page":"Home","title":"WunDeeDB.bulk_insert_embedding","text":"bulkinsertembedding(dbpath::String, collectionname::String, idtexts::Vector{<:AbstractString}, embeddings::Vector{<:AbstractVector{<:Number}}; datatype::Union{Nothing,String}=nothing) -> Union{String}\n\nA convenience wrapper for bulk inserting embedding records into an SQLite database using a database file path.\n\nThis function opens the SQLite database located at dbpath, calls the primary bulkinsert_embedding to insert the specified records into the given collection (table), and ensures that the database connection is closed. If an error occurs during the insertion process, a descriptive error message is returned.\n\n# Arguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table where embeddings will be inserted.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings for the new records.\nembeddings::Vector{<:AbstractVector{<:Number}}: A vector of embedding vectors to be inserted. All embeddings must have the same length.\ndata_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If omitted, it is inferred from the first embedding.\n\nReturns\n\nOn success: A String with the value \"true\".\nOn error: A String containing a descriptive error message.\n\nExample\n\n```julia result = bulkinsertembedding(\"mydatabase.sqlite\", \"embeddings\", [\"id1\", \"id2\"], [[1.0, 2.0], [3.0, 4.0]]) if startswith(result, \"Error:\")     println(\"Bulk insert failed: \", result) else     println(\"Bulk insert successful: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_update_embedding-Tuple{SQLite.DB, String, Vector{<:AbstractString}, Vector{<:AbstractVector{<:Number}}}","page":"Home","title":"WunDeeDB.bulk_update_embedding","text":"bulkupdateembedding(db::SQLite.DB, collectionname::String,          idtexts::Vector{<:AbstractString}, newembeddings::Vector{<:AbstractVector{<:Number}};         datatype::Union{Nothing,String}=nothing) -> String\n\nPerform a bulk update of embedding vectors in the specified collection (table) within an SQLite database.\n\nThis function updates multiple rows at once by setting a new embedding (stored as a JSON string) and updating the data type for each specified identifier in id_texts. The function verifies that:\n\nThe number of identifiers does not exceed a predefined bulk limit (BULK_LIMIT).\nThe number of new embedding vectors matches the number of identifiers.\nAll provided embedding vectors have the same length.\n\nIf the optional data_type is not provided, it is inferred from the first embedding vector using infer_data_type.\n\nThe updates are executed within a single SQLite transaction to ensure atomicity. For each identifier, the function:\n\nConverts the corresponding embedding vector to a JSON string using to_json_embedding.\nExecutes an UPDATE statement to set embedding_json and data_type for the row where id_text matches the identifier.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table containing the embeddings.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings corresponding to the rows to update.\nnew_embeddings::Vector{<:AbstractVector{<:Number}}: A vector of new embedding vectors. Every embedding must be of the same length.\ndata_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embeddings. If omitted, the data type is inferred from the first embedding.\n\nReturns\n\nA String (\"true\") if the update is successful.\n\nRaises\n\nAn error if:\nThe number of identifiers exceeds BULK_LIMIT.\nThere is a mismatch between the number of identifiers and the number of new embeddings.\nThe provided embedding vectors do not all have the same length.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") ids = [\"id1\", \"id2\", \"id3\"] newembs = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]] result = bulkupdateembedding(db, \"embeddings\", ids, newembs) println(\"Bulk update result: \", result)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.bulk_update_embedding-Tuple{String, String, Vector{<:AbstractString}, Vector{<:AbstractVector{<:Number}}}","page":"Home","title":"WunDeeDB.bulk_update_embedding","text":"bulkupdateembedding(dbpath::String, collectionname::String, idtexts::Vector{<:AbstractString}, newembeddings::Vector{<:AbstractVector{<:Number}}; data_type::Union{Nothing,String}=nothing) -> Union{String}\n\nA convenience wrapper for performing a bulk update of embedding vectors using a database file path.\n\nThis function opens the SQLite database located at dbpath and then calls the primary bulkupdate_embedding function to update the embeddings for the specified identifiers in the given collection (table). The function ensures that the database connection is properly closed after the operation. In case an error occurs during the update, a descriptive error message is returned as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table containing the embeddings.\nid_texts::Vector{<:AbstractString}: A vector of identifier strings corresponding to the rows to update.\nnew_embeddings::Vector{<:AbstractVector{<:Number}}: A vector of new embedding vectors. All embeddings must be of the same length.\ndata_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embeddings. If omitted, the data type is inferred from the first embedding.\n\nReturns\n\nOn success: A String (\"true\") indicating that the update was successful.\nOn error: A String containing the error message.\n\nExample\n\n```julia result = bulkupdateembedding(\"mydatabase.sqlite\", \"embeddings\", [\"id1\", \"id2\"], [[1.0, 2.0], [3.0, 4.0]]) if startswith(result, \"Error:\")     println(\"Bulk update failed: \", result) else     println(\"Bulk update successful: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.close_db-Tuple{SQLite.DB}","page":"Home","title":"WunDeeDB.close_db","text":"close_db(db::SQLite.DB)\n\nClose an open SQLite database connection.\n\nThis function is a simple wrapper around SQLite.close to ensure that the provided database connection is properly closed when it is no longer needed.\n\nArguments\n\ndb::SQLite.DB: The SQLite database connection to be closed.\n\nExample\n\n```julia db = open_db(\"data/mydatabase.sqlite\")\n\nPerform database operations...\n\nclose_db(db)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.count_entries-Tuple{SQLite.DB, String}","page":"Home","title":"WunDeeDB.count_entries","text":"countentries(db::SQLite.DB, collectionname::String; update_meta::Bool=false) -> Int\n\nCount the total number of entries (rows) in the specified collection (table) from an SQLite database, and optionally update the associated metadata table.\n\nThis function performs an SQL COUNT(*) query on the table named collection_name to obtain the number of rows. It retrieves the count from a result set containing a named tuple with the field count. Optionally, if the keyword argument update_meta is set to true, the function updates the metadata table, which is assumed to be named $(collection_name)_meta. The metadata update behavior is as follows:\n\nIf count > 0: Update the row_num field with the current count.\nIf count == 0: Clear the metadata by setting row_num to 0 and vector_length to NULL.\n\nArguments\n\ndb::SQLite.DB: An open connection to an SQLite database.\ncollection_name::String: The name of the table whose entries are to be counted.\nupdate_meta::Bool=false: Optional flag indicating whether to update the metadata table based on the count.\n\nReturns\n\nInt: The number of entries (rows) in the specified table.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") numentries = countentries(db, \"embeddings\"; updatemeta=true) println(\"Number of entries: \", numentries)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.count_entries-Tuple{String, String}","page":"Home","title":"WunDeeDB.count_entries","text":"countentries(dbpath::String, collectionname::String; updatemeta::Bool=false) -> Union{Int, String}\n\nA convenience wrapper for counting entries in a specified table of an SQLite database by using a file path. This function opens an SQLite database using dbpath, delegates the counting to countentries(db::SQLite.DB, collectionname; updatemeta::Bool=false), and then ensures that the database connection is closed after the operation. In case an error occurs during the process, the function returns a descriptive error message as a string.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table whose entries are to be counted.\nupdate_meta::Bool=false: Optional flag indicating whether to update the metadata table.\n\nReturns\n\nOn success: An Int representing the number of entries in the table.\nOn error: A String containing the error message.\n\nExample\n\n```julia result = countentries(\"mydatabase.sqlite\", \"embeddings\"; updatemeta=true) if isa(result, String)     println(\"Error occurred: \", result) else     println(\"Number of entries: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.delete_embedding-Tuple{SQLite.DB, String, Any}","page":"Home","title":"WunDeeDB.delete_embedding","text":"deleteembedding(db::SQLite.DB, collectionname::String, id_text) -> String\n\nDelete a single embedding record from the specified collection (table) in an SQLite database.\n\nThis function performs the following steps within a single SQLite transaction:\n\nRecord Existence Check:   It verifies that a record with the specified id_text exists in the table collection_name by executing a SELECT query.   If no matching record is found, an error with the message \"notfound\" is raised.\nDeletion:   If the record exists, the function deletes the corresponding row from the table using a DELETE SQL command.\nMetadata Update:   After deleting the record, it calls update_meta_delete on the associated metadata table (assumed to be named $(collection_name)_meta) to update any metadata related to the deletion.\n\nArguments\n\ndb::SQLite.DB: An active SQLite database connection.\ncollection_name::String: The name of the table from which the embedding record should be deleted.\nid_text: The identifier of the record to delete (this value is converted to a string for SQL operations).\n\nReturns\n\nA String with the value \"true\" if the deletion (and metadata update) is successful.\n\nRaises\n\nAn error with the message \"notfound\" if no record with the specified id_text exists.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") result = delete_embedding(db, \"embeddings\", \"record123\") if result == \"true\"     println(\"Record deleted successfully.\") else     println(\"Deletion error: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.delete_embedding-Tuple{String, String, Any}","page":"Home","title":"WunDeeDB.delete_embedding","text":"deleteembedding(dbpath::String, collectionname::String, idtext) -> Union{String}\n\nA convenience wrapper for deleting a single embedding record from an SQLite database by specifying the database file path.\n\nThis function opens the SQLite database at dbpath, calls the primary deleteembedding function to delete the specified record, and then ensures that the database connection is properly closed. If an error occurs during deletion, a descriptive error message is returned as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table from which the record is to be deleted.\nid_text: The identifier of the record to delete (converted to a string for SQL operations).\n\nReturns\n\nOn success: A String with the value \"true\" indicating the record was successfully deleted.\nOn error: A String containing a descriptive error message.\n\nExample\n\n```julia result = delete_embedding(\"mydatabase.sqlite\", \"embeddings\", \"record123\") if startswith(result, \"Error:\")     println(\"Deletion failed: \", result) else     println(\"Record deleted successfully.\") end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_embedding-Tuple{SQLite.DB, String, Any}","page":"Home","title":"WunDeeDB.get_embedding","text":"getembedding(db::SQLite.DB, collectionname::String, id_text) -> Union{Vector{T}, Nothing} where T\n\nRetrieve the embedding vector for a given identifier from a specified collection (table) in an SQLite database.\n\nThis function queries the table collection_name for the row where the id_text matches the provided identifier (converted to a string). The table is expected to have two columns:\n\nembedding_json: A JSON-encoded string representing the embedding vector.\ndata_type: A string that specifies the type of the elements in the embedding vector.\n\nThe JSON string is parsed into a Julia vector using JSON3.read with the element type determined by the helper function parse_data_type. If no matching row is found, the function returns nothing.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table (collection) to query.\nid_text: The identifier for which the embedding is requested (this value is converted to a string).\n\nReturns\n\nA vector representing the parsed embedding if a matching row is found.\nnothing if no row with the specified id_text exists.\n\nExample\n\n```julia embedding = get_embedding(db, \"embeddings\", \"id123\") if embedding === nothing     println(\"No embedding found for the given id.\") else     println(\"Retrieved embedding: \", embedding) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_embedding-Tuple{String, String, Any}","page":"Home","title":"WunDeeDB.get_embedding","text":"getembedding(dbpath::String, collectionname::String, idtext) -> Union{Vector{T}, Nothing, String} where T\n\nA convenience wrapper for retrieving an embedding vector from a specified SQLite database by using the database file path.\n\nThis function opens the SQLite database located at dbpath, delegates the retrieval of the embedding to getembedding(db::SQLite.DB, collectionname, idtext), and then ensures that the database connection is closed. In the event of an error during the operation, the function returns a descriptive error message as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table (collection) to query.\nid_text: The identifier for which the embedding is requested (converted to a string).\n\nReturns\n\nOn success: A vector representing the parsed embedding if found, or nothing if no matching row exists.\nOn error: A String containing an error message.\n\nExample ```julia embedding = get_embedding(\"mydatabase.sqlite\", \"embeddings\", \"id123\") if isa(embedding, String)     println(\"Error: \", embedding) elseif embedding === nothing     println(\"No embedding found for the given id.\") else     println(\"Retrieved embedding: \", embedding) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_embedding_size-Tuple{SQLite.DB, String}","page":"Home","title":"WunDeeDB.get_embedding_size","text":"getembeddingsize(db::SQLite.DB, collection_name::String) -> Int\n\nFetch the embedding vector size for a given collection from the metadata table in an SQLite database.\n\nThis function queries the metadata table associated with the collection, which is assumed to be named  $(collection_name)_meta, and retrieves the value of the vector_length column. If no metadata is found,  the function returns 0; otherwise, it returns the embedding size from the first row of the query result.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The base name of the collection whose embedding size is to be retrieved. The metadata table is expected to be named as $(collection_name)_meta.\n\nReturns\n\nInt: The embedding vector size if metadata is found, or 0 if no metadata exists.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") embeddingsize = getembeddingsize(db, \"embeddings\") println(\"Embedding size: \", embeddingsize)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_embedding_size-Tuple{String, String}","page":"Home","title":"WunDeeDB.get_embedding_size","text":"getembeddingsize(dbpath::String, collectionname::String) -> Union{Int, String}\n\nA convenience wrapper for retrieving the embedding size from an SQLite database using a file path.\n\nThis function opens an SQLite database using the provided dbpath and delegates the retrieval of the embedding size to getembeddingsize(db::SQLite.DB, collectionname). It ensures that the database connection is closed after the operation. If an error occurs during the process, the function returns a string with the error message.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollectionname::String: The base name of the collection. The metadata table is expected to be named $(Expr(:incomplete, Base.Meta.ParseError(\"ParseError:\\n# Error @ none:1:12\\n(collection\\n#          └ ── Expected `)`\", Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(\"(collection\", 0, \"none\", 1, [1, 12]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(12, 11, :error, \"Expected `)`\")], :other))))name)_meta.\n\nReturns\n\nOn success: An Int representing the embedding vector size.\nOn error: A String containing an error message.\n\nExample\n\n```julia embeddingsize = getembeddingsize(\"mydatabase.sqlite\", \"embeddings\") if isa(embeddingsize, String)     println(\"Error occurred: \", embeddingsize) else     println(\"Embedding size: \", embeddingsize) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_next_id-Tuple{SQLite.DB, String, Any}","page":"Home","title":"WunDeeDB.get_next_id","text":"getnextid(db::SQLite.DB, collectionname::String, currentid; full_row::Bool=false) -> Union{Nothing, Any}\n\nRetrieve the entry that immediately follows a given current_id in lexicographical (alphabetical) order from the specified collection (table) in an SQLite database.\n\nThis function searches for the row in collection_name where the id_text is lexicographically greater than current_id. The SQL query uses the condition WHERE id_text > ? and orders the results in ascending lexicographical order (ORDER BY id_text ASC), ensuring that the smallest id_text greater than current_id is returned.\n\nWhen full_row is false (default):   Only the id_text of the next entry is returned.\nWhen full_row is true:   The function returns a NamedTuple containing:\nid_text: The identifier of the entry.\nembedding: The embedding vector parsed from the JSON string found in the embedding_json field.\ndata_type: The data type indicator used for parsing the embedding (with the appropriate type determined by parse_data_type).\n\nIf no such entry is found (i.e., there is no row with an id_text lexicographically greater than current_id), the function returns nothing.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table (collection) to query.\ncurrent_id: The current identifier for comparison (expected to be a string or a type compatible with lexicographical ordering).\nfull_row::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding); otherwise, only the id_text is returned.\n\nReturns\n\nIf a next entry is found:\nDefault (full_row == false): Returns the id_text of the next entry.\nIf full_row == true: Returns a NamedTuple with fields id_text, embedding, and data_type.\nIf no entry is found: Returns nothing.\n\nExample\n\n```julia\n\nRetrieve only the next id based on lexicographical ordering:\n\nnextid = getnextid(db, \"embeddings\", currentid) println(\"Next ID (lexicographical): \", next_id)\n\nRetrieve the full next row with parsed embedding:\n\nnextrow = getnextid(db, \"embeddings\", currentid; fullrow=true) if nextrow !== nothing     @show nextrow.idtext, nextrow.embedding, nextrow.data_type else     println(\"No next entry found based on lexicographical ordering.\") end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_next_id-Tuple{String, String, Any}","page":"Home","title":"WunDeeDB.get_next_id","text":"getnextid(dbpath::String, collectionname::String, currentid; fullrow::Bool=false) -> Union{Nothing, Any, String}\n\nA convenience wrapper for retrieving the entry that immediately follows a given current_id (based on lexicographical ordering) from a specified collection using a database file path.\n\nThis function opens an SQLite database using the provided dbpath and delegates the retrieval of the next entry to getnextid(db::SQLite.DB, collectionname, currentid; fullrow::Bool=false). The lexicographical comparison (WHERE idtext > ?) ensures that the smallest idtext greater than current_id is returned. The database connection is closed after the operation, and any errors encountered are returned as a descriptive string. Arguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table (collection) to query.\ncurrent_id: The current identifier used for comparison.\nfullrow::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding); otherwise, only the idtext is returned.\n\nReturns\n\nOn success:\nIf a next entry is found:\nDefault (fullrow == false): Returns the idtext of the next entry.\nIf fullrow == true): Returns a NamedTuple with fields idtext, embedding, and data_type.\nIf no entry is found: Returns nothing.\nOn error: Returns a String containing the error message.\n\nExample\n\n```julia result = getnextid(\"mydatabase.sqlite\", \"embeddings\", currentid; fullrow=true) if isa(result, String)     println(\"Error: \", result) elseif result === nothing     println(\"No next entry found based on lexicographical ordering.\") else     @show result.idtext, result.embedding, result.datatype end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_previous_id-Tuple{SQLite.DB, String, Any}","page":"Home","title":"WunDeeDB.get_previous_id","text":"getpreviousid(db::SQLite.DB, collectionname::String, currentid; full_row::Bool=false) -> Union{Nothing, Any}\n\nRetrieve the entry that immediately precedes a given current_id in lexicographical (alphabetical) order from the specified collection (table) in an SQLite database.\n\nThis function searches for the row in collection_name where the id_text is lexicographically less than current_id. The comparison is performed using standard string ordering (i.e., alphabetical order), so it is assumed that the id_text values are stored as strings. The query orders the results in descending lexicographical order by id_text, ensuring that the row with the closest preceding id_text is selected.\n\nWhen full_row is false (default):   The function returns only the id_text of the previous entry.\nWhen full_row is true:   The function returns a NamedTuple containing:\nid_text: The identifier of the entry.\nembedding: The embedding vector parsed from the JSON string in the embedding_json field.\ndata_type: The data type indicator used to parse the embedding (with the type determined by parse_data_type).\n\nIf no entry is found (i.e., there is no row with an id_text lexicographically less than current_id), the function returns nothing.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table (collection) to query.\ncurrent_id: The current identifier used for comparison (expected to be a string or compatible type).\nfull_row::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding), or false to retrieve only the id_text.\n\nReturns\n\nIf a previous entry is found:\nDefault (full_row == false): Returns the id_text of the previous entry.\nIf full_row == true: Returns a NamedTuple with fields id_text, embedding, and data_type.\nIf no previous entry is found: Returns nothing.\n\nExample\n\n```julia\n\nRetrieve only the previous id based on lexicographical ordering:\n\nprevid = getpreviousid(db, \"embeddings\", currentid) println(\"Previous ID (lexicographical): \", prev_id)\n\nRetrieve the full previous row with parsed embedding:\n\nprevrow = getpreviousid(db, \"embeddings\", currentid; fullrow=true) if prevrow !== nothing     @show prevrow.idtext, prevrow.embedding, prevrow.data_type else     println(\"No previous entry found based on lexicographical ordering.\") end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.get_previous_id-Tuple{String, String, Any}","page":"Home","title":"WunDeeDB.get_previous_id","text":"getpreviousid(dbpath::String, collectionname::String, currentid; fullrow::Bool=false) -> Union{Nothing, Any, String}\n\nA convenience wrapper for retrieving the entry immediately preceding a given current_id (based on lexicographical ordering) from a collection by specifying the database file path.\n\nThis function opens an SQLite database using the provided dbpath and delegates the task to getpreviousid(db::SQLite.DB, collectionname, currentid; fullrow::Bool=false). The comparison of id_text values is performed lexicographically (alphabetically), ensuring that the row with the closest preceding identifier is selected. The database connection is properly closed after the operation. In the event of an error, the function returns a descriptive error message as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table (collection) to query.\ncurrent_id: The current identifier used for comparison (expected to be a string or a compatible type).\nfullrow::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding), or false to retrieve only the idtext.\n\nReturns\n\nOn success:\nIf a previous entry is found:\nDefault (fullrow == false): Returns the idtext of the previous entry.\nIf fullrow == true: Returns a NamedTuple with fields idtext, embedding, and data_type.\nIf no previous entry is found: Returns nothing.\nOn error: Returns a String containing the error message.\n\nExample\n\n```julia result = getpreviousid(\"mydatabase.sqlite\", \"embeddings\", currentid; fullrow=true) if isa(result, String)     println(\"Error: \", result) elseif result === nothing     println(\"No previous entry found based on lexicographical ordering.\") else     @show result.idtext, result.embedding, result.datatype end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.initialize_db-Tuple{String, String}","page":"Home","title":"WunDeeDB.initialize_db","text":"initializedb(dbpath::String, collection_name::String) -> String\n\nInitialize an SQLite database for storing embedding records and corresponding metadata.\n\nThis function performs the following operations:\n\nOpens the SQLite database located at db_path.\nConfigures the database for improved write performance by setting:\njournal_mode to WAL (Write-Ahead Logging).\nsynchronous to NORMAL.\nCreates the main table for storing embeddings if it does not already exist. The table is named as specified by collection_name and includes:\nid_text (TEXT PRIMARY KEY): A unique identifier for each embedding record.\nembedding_json (TEXT NOT NULL): The JSON-encoded embedding vector.\ndata_type (TEXT): A column to store information about the data type of the embedding.\nCreates a metadata table (named $(collection_name)_meta) if it does not already exist. This table stores:\nrow_num (BIGINT): The number of embedding records.\nvector_length (INT): The length of the embedding vectors.\n\nAfter performing these steps, the function closes the database connection. On successful initialization, it returns \"true\".   If an error occurs during the process, the function ensures that the database is closed and returns an error message string.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The base name for the main collection table. The associated metadata table will be named as $(collection_name)_meta.\n\nReturns\n\nA String:\n\"true\" if the database is successfully initialized.\nA descriptive error message if an error occurs.\n\nExample\n\n```julia result = initialize_db(\"mydatabase.sqlite\", \"embeddings\") if result == \"true\"     println(\"Database initialized successfully.\") else     println(\"Database initialization failed: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.insert_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{<:Number}}","page":"Home","title":"WunDeeDB.insert_embedding","text":"insertembedding(db::SQLite.DB, collectionname::String, idtext, embedding::AbstractVector{<:Number};                       datatype::Union{Nothing,String}=nothing) -> String\n\nInsert a single embedding record into the specified collection (table) within an SQLite database.\n\nThis function performs the following steps:\n\nData Type Handling:   If data_type is not provided, it is inferred from the embedding using infer_data_type(embedding).\nEmbedding Conversion:   The embedding vector is converted to a JSON string using to_json_embedding(embedding).\nAtomic Insertion and Metadata Update:   The insertion of the record and the subsequent update of the associated metadata table (named $(collection_name)_meta) are performed within a single SQLite transaction.   The metadata is updated via update_meta(db, \"$(collection_name)_meta\", length(embedding)), which records the dimension of the embedding.\n\nArguments\n\ndb::SQLite.DB: An active SQLite database connection.\ncollection_name::String: The name of the table where the embedding record is stored.\nid_text: The unique identifier for the record (converted to a string for the query).\nembedding::AbstractVector{<:Number}: The embedding vector to be inserted.\ndata_type::Union{Nothing,String}=nothing: Optional. A string specifying the data type of the embedding values. If not provided, the data type is inferred from the embedding.\n\nReturns\n\nA String with the value \"true\" indicating a successful insertion.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") id = \"record123\" emb = [0.1, 0.2, 0.3, 0.4] result = insert_embedding(db, \"embeddings\", id, emb) println(\"Insert result: \", result)  # Expected output: \"true\"\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.insert_embedding-Tuple{String, String, Any, AbstractVector{<:Number}}","page":"Home","title":"WunDeeDB.insert_embedding","text":"insertembedding(dbpath::String, collectionname::String, idtext, embedding::AbstractVector{<:Number}; data_type::Union{Nothing,String}=nothing) -> Union{String}\n\nA convenience wrapper for inserting a single embedding record into an SQLite database by specifying the database file path.\n\nThis function:\n\nOpens the SQLite database at the given db_path.\nDelegates the record insertion to insertembedding(db, collectionname, idtext, embedding; datatype=data_type).\nEnsures that the database connection is closed after the operation.\nReturns a descriptive error message if an exception occurs.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table where the embedding will be inserted.\nid_text: The unique identifier for the record (converted to a string for the query).\nembedding::AbstractVector{<:Number}: The embedding vector to be inserted.\ndata_type::Union{Nothing,String}=nothing: Optional. A string specifying the data type of the embedding values. If omitted, the data type is inferred from the embedding.\n\nReturns\n\nOn success: A String with the value \"true\".\nOn error: A String containing a descriptive error message.\n\nExample\n\n```julia result = insert_embedding(\"mydatabase.sqlite\", \"embeddings\", \"record123\", [0.1, 0.2, 0.3, 0.4]) if startswith(result, \"Error:\")     println(\"Insert failed: \", result) else     println(\"Record inserted successfully.\") end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.open_db-Tuple{String}","page":"Home","title":"WunDeeDB.open_db","text":"opendb(dbpath::String) -> SQLite.DB\n\nOpen an SQLite database located at the specified file path, ensuring that the directory exists.\n\nThis function performs the following steps:\n\nDirectory Check and Creation:   It determines the directory path for db_path and checks whether it exists. If the directory does not exist, the function attempts to create it using mkpath.   If directory creation fails, an error is raised with a descriptive message.\nDatabase Connection and Configuration:   The function opens an SQLite database connection using SQLite.DB(db_path).   It then sets two PRAGMA options for improved write performance:\njournal_mode is set to WAL (Write-Ahead Logging).\nsynchronous is set to NORMAL.\nReturn Value:   The configured SQLite database connection is returned.\n\nArguments\n\ndb_path::String: The file path to the SQLite database. The function will ensure that the directory containing this file exists.\n\nReturns\n\nAn instance of SQLite.DB representing the open and configured database connection.\n\nExample\n\n```julia db = open_db(\"data/mydatabase.sqlite\")\n\nUse the database connection...\n\nSQLite.execute(db, \"SELECT * FROM my_table;\")\n\nDon't forget to close the database when done.\n\nclose_db(db)\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.random_embeddings-Tuple{SQLite.DB, String, Int64}","page":"Home","title":"WunDeeDB.random_embeddings","text":"randomembeddings(db::SQLite.DB, collectionname::String, num::Int) -> Vector{Dict{String,Any}}\n\nRetrieve a specified number of random embedding records from a given collection in an SQLite database.\n\nThis function performs an SQL query against the specified collection_name (which is typically the name of a table in the database) to fetch up to num random rows. Each row is expected to have the following columns:\n\nid_text: An identifier for the embedding.\nembedding_json: A JSON string representing the embedding vector.\ndata_type: A string indicating the data type of the elements within the embedding.\n\nThe JSON in embedding_json is parsed using JSON3 into a Vector{T}, where the type T is determined by the data_type field (via the helper function parse_data_type).\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table/collection from which to retrieve embeddings.\nnum::Int: The number of random embeddings to retrieve. This value must be between 1 and BULK_LIMIT.\n\nReturns\n\nA Vector{Dict{String, Any}} where each dictionary has the following keys:\n\n\"id_text\": The unique identifier for the embedding.\n\"embedding\": The embedding vector (parsed from JSON).\n\"data_type\": The data type string that was used to parse the embedding.\n\nThrows\n\nRaises an error if num is less than 1 or greater than BULK_LIMIT.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") embeddings = randomembeddings(db, \"embeddingstable\", 5) for record in embeddings     @show record[\"idtext\"], record[\"embedding\"], record[\"datatype\"] end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.random_embeddings-Tuple{String, String, Int64}","page":"Home","title":"WunDeeDB.random_embeddings","text":"randomembeddings(dbpath::String, collection_name::String, num::Int) -> Union{Vector{Dict{String,Any}}, String}\n\nA convenience wrapper to retrieve random embedding records by providing a database file path.\n\nThis function opens an SQLite database using the file path dbpath, then delegates the task of fetching random embeddings to the randomembeddings(db::SQLite.DB, collection_name, num) function. Once the data has been retrieved (or an error occurs), the database connection is properly closed. In the event of an exception during retrieval, the function returns a string that describes the error.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table/collection from which to retrieve embeddings.\nnum::Int: The number of random embeddings to retrieve. This value must be between 1 and BULK_LIMIT.\n\nReturns\n\nOn success: A Vector{Dict{String, Any}} where each dictionary contains keys \"id_text\", \"embedding\", and \"data_type\".\nOn failure: A String containing an error message.\n\nExample\n\nresult = randomembeddings(\"mydatabase.sqlite\", \"embeddingstable\", 5) if typeof(result) == String     println(\"An error occurred: \", result) else     for record in result         @show record[\"idtext\"], record[\"embedding\"], record[\"datatype\"]     end end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.update_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{<:Number}}","page":"Home","title":"WunDeeDB.update_embedding","text":"updateembedding(db::SQLite.DB, collectionname::String, idtext, newembedding::AbstractVector{<:Number};                      data_type::Union{Nothing,String}=nothing) -> String\n\nUpdate the embedding vector for a specified record in the given collection (table) within an SQLite database.\n\nThis function performs several key steps within a single SQLite transaction:\n\nRecord Existence Check:   It first verifies that a record with the given id_text exists in the table collection_name.   If no record is found, the function raises an error with the message \"notfound\".\nMetadata Retrieval and Dimension Validation:   The function retrieves metadata from the associated metadata table (named as $(collection_name)_meta) to obtain the stored embedding vector length (vector_length).   If the metadata is missing, an error is raised indicating that no metadata was found.   It then compares the stored length with the length of the new embedding vector (new_embedding).   If the lengths do not match, an error is raised with details about the mismatch.\nEmbedding Conversion and Data Type Determination:   The new embedding vector is converted to a JSON string using to_json_embedding.   If the optional data_type parameter is not provided, it is inferred from the new embedding using infer_data_type.\nRecord Update:   Finally, the function updates the record in the table collection_name by setting the embedding_json and data_type fields for the row where id_text matches the provided identifier.\n\nArguments\n\ndb::SQLite.DB: An active connection to an SQLite database.\ncollection_name::String: The name of the table containing the embeddings.\nid_text: The identifier of the record to update (converted to a string for the query).\nnew_embedding::AbstractVector{<:Number}: The new embedding vector to be stored.\ndata_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If not provided, the data type is inferred from new_embedding.\n\nReturns\n\nA String with the value \"true\" indicating a successful update.\n\nRaises\n\n\"notfound\": If no record with the specified id_text exists in collection_name.\nAn error if no metadata is found in the associated metadata table.\nAn error if the new embedding's length does not match the stored vector_length.\n\nExample\n\n```julia db = SQLite.DB(\"mydatabase.sqlite\") id = \"record123\" newvec = [0.1, 0.2, 0.3, 0.4] result = updateembedding(db, \"embeddings\", id, new_vec) if result == \"true\"     println(\"Embedding updated successfully.\") else     println(\"Update failed: \", result) end\n\n\n\n\n\n","category":"method"},{"location":"#WunDeeDB.update_embedding-Tuple{String, String, Any, AbstractVector{<:Number}}","page":"Home","title":"WunDeeDB.update_embedding","text":"updateembedding(dbpath::String, collectionname::String, idtext, newembedding::AbstractVector{<:Number}; datatype::Union{Nothing,String}=nothing) -> Union{String}\n\nA convenience wrapper for updating an embedding vector using a database file path.\n\nThis function opens the SQLite database specified by dbpath and then calls the primary updateembedding function to update the embedding for the specified record in the collection (table). It ensures that the database connection is properly closed after the operation. If an error occurs during the update, a descriptive error message is returned as a String.\n\nArguments\n\ndb_path::String: The file path to the SQLite database.\ncollection_name::String: The name of the table containing the embeddings.\nid_text: The identifier of the record to update.\nnew_embedding::AbstractVector{<:Number}: The new embedding vector to be stored.\ndatatype::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If omitted, it is inferred from newembedding.\n\nReturns\n\nOn success: A String with the value \"true\".\nOn error: A String containing a descriptive error message.\n\nExample\n\n```julia result = update_embedding(\"mydatabase.sqlite\", \"embeddings\", \"record123\", [0.1, 0.2, 0.3, 0.4]) if startswith(result, \"Error:\")     println(\"Update failed: \", result) else     println(\"Embedding updated successfully.\") end\n\n\n\n\n\n","category":"method"}]
}
