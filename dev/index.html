<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · WunDeeDB.jl</title><meta name="title" content="Home · WunDeeDB.jl"/><meta property="og:title" content="Home · WunDeeDB.jl"/><meta property="twitter:title" content="Home · WunDeeDB.jl"/><meta name="description" content="Documentation for WunDeeDB.jl."/><meta property="og:description" content="Documentation for WunDeeDB.jl."/><meta property="twitter:description" content="Documentation for WunDeeDB.jl."/><meta property="og:url" content="https://mantzaris.github.io/WunDeeDB.jl/"/><meta property="twitter:url" content="https://mantzaris.github.io/WunDeeDB.jl/"/><link rel="canonical" href="https://mantzaris.github.io/WunDeeDB.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WunDeeDB.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mantzaris/WunDeeDB.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mantzaris/WunDeeDB.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#WunDeeDB">WunDeeDB</a></li><li class="no-marker"><ul><li><a href="#Introduction">Introduction</a></li></ul></li></ul><h1 id="WunDeeDB"><a class="docs-heading-anchor" href="#WunDeeDB">WunDeeDB</a><a id="WunDeeDB-1"></a><a class="docs-heading-anchor-permalink" href="#WunDeeDB" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/mantzaris/WunDeeDB.jl">WunDeeDB</a>.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This module supports bulk operations (insertions, deletions, and updates) with a hard limit of 1000 records per operation. In addition, the module supports the following numerical types for embedding data:</p><ul><li>Float16</li><li>Float32</li><li>Float64</li><li>BigFloat</li><li>Int8</li><li>UInt8</li><li>Int16</li><li>UInt16</li><li>Int32</li><li>UInt32</li><li>Int64</li><li>UInt64</li><li>Int128</li><li>UInt128</li></ul><p>These types are defined in the DATA<em>TYPE</em>MAP and are used to correctly parse and manage the embedding vectors stored in the SQLite database. The constant BULK_LIMIT is set to 1000 to prevent overly large transactions during bulk operations.</p><ul><li><a href="#WunDeeDB.bulk_delete_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_delete_embedding</code></a></li><li><a href="#WunDeeDB.bulk_delete_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_delete_embedding</code></a></li><li><a href="#WunDeeDB.bulk_get_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_get_embedding</code></a></li><li><a href="#WunDeeDB.bulk_get_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_get_embedding</code></a></li><li><a href="#WunDeeDB.bulk_insert_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_insert_embedding</code></a></li><li><a href="#WunDeeDB.bulk_insert_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_insert_embedding</code></a></li><li><a href="#WunDeeDB.bulk_update_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_update_embedding</code></a></li><li><a href="#WunDeeDB.bulk_update_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_update_embedding</code></a></li><li><a href="#WunDeeDB.close_db-Tuple{SQLite.DB}"><code>WunDeeDB.close_db</code></a></li><li><a href="#WunDeeDB.count_entries-Tuple{String, String}"><code>WunDeeDB.count_entries</code></a></li><li><a href="#WunDeeDB.count_entries-Tuple{SQLite.DB, String}"><code>WunDeeDB.count_entries</code></a></li><li><a href="#WunDeeDB.delete_embedding-Tuple{String, String, Any}"><code>WunDeeDB.delete_embedding</code></a></li><li><a href="#WunDeeDB.delete_embedding-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.delete_embedding</code></a></li><li><a href="#WunDeeDB.get_embedding-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_embedding</code></a></li><li><a href="#WunDeeDB.get_embedding-Tuple{String, String, Any}"><code>WunDeeDB.get_embedding</code></a></li><li><a href="#WunDeeDB.get_embedding_size-Tuple{SQLite.DB, String}"><code>WunDeeDB.get_embedding_size</code></a></li><li><a href="#WunDeeDB.get_embedding_size-Tuple{String, String}"><code>WunDeeDB.get_embedding_size</code></a></li><li><a href="#WunDeeDB.get_next_id-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_next_id</code></a></li><li><a href="#WunDeeDB.get_next_id-Tuple{String, String, Any}"><code>WunDeeDB.get_next_id</code></a></li><li><a href="#WunDeeDB.get_previous_id-Tuple{String, String, Any}"><code>WunDeeDB.get_previous_id</code></a></li><li><a href="#WunDeeDB.get_previous_id-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_previous_id</code></a></li><li><a href="#WunDeeDB.initialize_db-Tuple{String, String}"><code>WunDeeDB.initialize_db</code></a></li><li><a href="#WunDeeDB.insert_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.insert_embedding</code></a></li><li><a href="#WunDeeDB.insert_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.insert_embedding</code></a></li><li><a href="#WunDeeDB.open_db-Tuple{String}"><code>WunDeeDB.open_db</code></a></li><li><a href="#WunDeeDB.random_embeddings-Tuple{String, String, Int64}"><code>WunDeeDB.random_embeddings</code></a></li><li><a href="#WunDeeDB.random_embeddings-Tuple{SQLite.DB, String, Int64}"><code>WunDeeDB.random_embeddings</code></a></li><li><a href="#WunDeeDB.update_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.update_embedding</code></a></li><li><a href="#WunDeeDB.update_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.update_embedding</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_delete_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}" href="#WunDeeDB.bulk_delete_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_delete_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>delete</em>embedding(db::SQLite.DB, collection<em>name::String, id</em>texts::Vector{&lt;:AbstractString}) -&gt; String</p><p>Delete multiple embedding records from the specified collection (table) in an SQLite database.</p><p>This function removes rows from the table named <code>collection_name</code> where the <code>id_text</code> is one of the provided identifiers. It enforces a limit on the number of identifiers via the predefined constant <code>BULK_LIMIT</code> to prevent overly large transactions. If the number of identifiers exceeds <code>BULK_LIMIT</code>, an error is raised.</p><p>The deletion process is executed within an SQLite transaction to ensure atomicity. After the deletion, the function updates the associated metadata table (assumed to be named <code>$(collection_name)_meta</code>) by calling <code>bulk_update_meta_delete</code>, which subtracts the number of deleted rows from the stored metadata.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table from which embeddings are to be deleted.</li><li><code>id_texts::Vector{&lt;:AbstractString}</code>: A vector of identifier strings corresponding to the rows to delete.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> with the value <code>&quot;true&quot;</code> if the deletion is successful.</li></ul><p><strong>Raises</strong></p><ul><li>An error if the number of identifiers exceeds <code>BULK_LIMIT</code>.</li><li>Any SQL errors encountered during the deletion or metadata update will propagate, causing the transaction to roll back.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) ids = [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;] result = bulk<em>delete</em>embedding(db, &quot;embeddings&quot;, ids) println(result)  # Should print &quot;true&quot; if the deletion and metadata update are successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L629-L661">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_delete_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}" href="#WunDeeDB.bulk_delete_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_delete_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>delete</em>embedding(db<em>path::String, collection</em>name::String, id_texts::Vector{&lt;:AbstractString}) -&gt; Union{String}</p><p>A convenience wrapper for deleting multiple embedding records from an SQLite database using a database file path.</p><p>This function opens the SQLite database located at db<em>path, calls the primary bulk</em>delete_embedding function to remove the specified rows from the given collection (table), and then ensures that the database connection is properly closed. If an error occurs during the deletion or metadata update, a descriptive error message is returned as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table from which embeddings are to be deleted.</li><li>id_texts::Vector{&lt;:AbstractString}: A vector of identifier strings corresponding to the rows to delete.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String with the value &quot;true&quot; indicating the deletion was successful.</li><li>On error: A String containing a descriptive error message.</li></ul><p><strong>Example</strong></p><p>```juila result = bulk<em>delete</em>embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;]) if startswith(result, &quot;Error:&quot;)     println(&quot;Bulk delete failed: &quot;, result) else     println(&quot;Bulk delete successful: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L681-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_get_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}" href="#WunDeeDB.bulk_get_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_get_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>get</em>embedding(db::SQLite.DB, collection<em>name::String, id</em>texts::Vector{&lt;:AbstractString}) -&gt; Dict{String,Any}</p><p>Retrieve embeddings in bulk from the specified collection (table) in an SQLite database, based on a vector of identifier strings.</p><p>This function first checks that the number of identifiers does not exceed a predefined bulk limit (<code>BULK_LIMIT</code>). It then constructs an SQL query using parameterized placeholders to select rows from the table <code>collection_name</code> where the <code>id_text</code> is one of the provided identifiers. For each returned row, it:</p><ul><li>Retrieves the <code>id_text</code>, JSON-encoded embedding (<code>embedding_json</code>), and <code>data_type</code>.</li><li>Uses the helper function <code>parse_data_type</code> to determine the correct type for the embedding.</li><li>Parses the JSON string into a vector using <code>JSON3.read</code>.</li><li>Inserts the resulting embedding vector into a dictionary with the corresponding <code>id_text</code> as the key.</li></ul><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>collection_name::String</code>: The name of the table (collection) to query.</li><li><code>id_texts::Vector{&lt;:AbstractString}</code>: A vector of identifier strings for which embeddings should be fetched.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Dict{String,Any}</code> mapping each <code>id_text</code> (as a <code>String</code>) to its corresponding embedding vector.</li></ul><p><strong>Raises</strong></p><ul><li>Throws an error if the number of identifiers exceeds the limit specified by <code>BULK_LIMIT</code>.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) ids = [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;] embeddings = bulk<em>get</em>embedding(db, &quot;embeddings&quot;, ids) for (id, emb) in embeddings     println(&quot;ID: &quot;, id, &quot; -&gt; Embedding: &quot;, emb) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1083-L1113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_get_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}" href="#WunDeeDB.bulk_get_embedding-Tuple{String, String, Vector{&lt;:AbstractString}}"><code>WunDeeDB.bulk_get_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>get</em>embedding(db<em>path::String, collection</em>name::String, id_texts::Vector{&lt;:AbstractString}) -&gt; Union{Dict{String,Any}, String}</p><p>A convenience wrapper for bulk fetching embeddings from an SQLite database by specifying the database file path.</p><p>This function opens the SQLite database located at db<em>path and calls the primary bulk</em>get<em>embedding function to retrieve embeddings for the provided id</em>texts. The function ensures that the database connection is closed after the operation, even if an error occurs. In case of an error during execution, a descriptive error message is returned as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table (collection) to query.</li><li>id_texts::Vector{&lt;:AbstractString}: A vector of identifier strings for which embeddings should be fetched.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A Dict{String,Any} mapping each id_text to its corresponding embedding vector.</li><li>On error: A String containing an error message.</li></ul><p><strong>Example</strong></p><p>```julia ids = [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;] result = bulk<em>get</em>embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, ids) if isa(result, String)     println(&quot;Error occurred: &quot;, result) else     for (id, emb) in result         println(&quot;ID: &quot;, id, &quot; -&gt; Embedding: &quot;, emb)     end end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1139-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_insert_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}" href="#WunDeeDB.bulk_insert_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_insert_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>insert</em>embedding(db::SQLite.DB, collection<em>name::String,                              id</em>texts::Vector{&lt;:AbstractString}, embeddings::Vector{&lt;:AbstractVector{&lt;:Number}};                             data_type::Union{Nothing,String}=nothing) -&gt; String</p><p>Bulk insert multiple embedding records into a specified collection (table) in an SQLite database.</p><p>This function performs several validation and insertion steps:</p><ol><li><p><strong>Validation:</strong></p><ul><li>Checks that the number of identifiers (in <code>id_texts</code>) does not exceed a predefined limit (<code>BULK_LIMIT</code>).</li><li>Verifies that the number of embedding vectors matches the number of IDs.</li><li>Ensures that all embedding vectors have the same length.</li><li>If <code>data_type</code> is not provided, it infers the data type from the first embedding vector using <code>infer_data_type</code>.</li></ul></li><li><p><strong>Parameter Preparation:</strong></p><ul><li>Constructs a list of tuples, each containing:<ul><li>The identifier (converted to a string).</li><li>The JSON-encoded embedding vector (using <code>JSON3.write</code>).</li><li>The determined <code>data_type</code>.</li></ul></li></ul></li><li><p><strong>Insertion Transaction:</strong></p><ul><li>Executes an INSERT statement for each record within a single SQLite transaction.</li><li>After all records are inserted, updates the associated metadata table (assumed to be named <code>$(collection_name)_meta</code>) via <code>update_meta_bulk</code> to reflect the new embedding dimension and row count.</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table where embeddings are stored.</li><li><code>id_texts::Vector{&lt;:AbstractString}</code>: A vector of identifier strings for the new records.</li><li><code>embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}</code>: A vector of embedding vectors to be inserted. All embeddings must be of the same length.</li><li><code>data_type::Union{Nothing, String}=nothing</code>: Optional. A string representing the data type of the embedding values. If omitted, the data type is inferred from the first embedding.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> with the value <code>&quot;true&quot;</code> if the bulk insertion is successful.</li></ul><p><strong>Raises</strong></p><ul><li>An error if the number of identifiers exceeds <code>BULK_LIMIT</code>.</li><li>An error if the number of embeddings does not match the number of IDs.</li><li>An error if the embedding vectors do not all have the same length.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) ids = [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;] embs = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]] result = bulk<em>insert</em>embedding(db, &quot;embeddings&quot;, ids, embs) println(&quot;Bulk insert result: &quot;, result)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L400-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_insert_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}" href="#WunDeeDB.bulk_insert_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_insert_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>insert</em>embedding(db<em>path::String, collection</em>name::String, id<em>texts::Vector{&lt;:AbstractString}, embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}; data</em>type::Union{Nothing,String}=nothing) -&gt; Union{String}</p><p>A convenience wrapper for bulk inserting embedding records into an SQLite database using a database file path.</p><p>This function opens the SQLite database located at db<em>path, calls the primary bulk</em>insert_embedding to insert the specified records into the given collection (table), and ensures that the database connection is closed. If an error occurs during the insertion process, a descriptive error message is returned.</p><pre><code class="nohighlight hljs"># Arguments</code></pre><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table where embeddings will be inserted.</li><li>id_texts::Vector{&lt;:AbstractString}: A vector of identifier strings for the new records.</li><li>embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}: A vector of embedding vectors to be inserted. All embeddings must have the same length.</li><li>data_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If omitted, it is inferred from the first embedding.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String with the value &quot;true&quot;.</li><li>On error: A String containing a descriptive error message.</li></ul><p><strong>Example</strong></p><p>```julia result = bulk<em>insert</em>embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, [&quot;id1&quot;, &quot;id2&quot;], [[1.0, 2.0], [3.0, 4.0]]) if startswith(result, &quot;Error:&quot;)     println(&quot;Bulk insert failed: &quot;, result) else     println(&quot;Bulk insert successful: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L489-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_update_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}" href="#WunDeeDB.bulk_update_embedding-Tuple{SQLite.DB, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_update_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>update</em>embedding(db::SQLite.DB, collection<em>name::String,          id</em>texts::Vector{&lt;:AbstractString}, new<em>embeddings::Vector{&lt;:AbstractVector{&lt;:Number}};         data</em>type::Union{Nothing,String}=nothing) -&gt; String</p><p>Perform a bulk update of embedding vectors in the specified collection (table) within an SQLite database.</p><p>This function updates multiple rows at once by setting a new embedding (stored as a JSON string) and updating the data type for each specified identifier in <code>id_texts</code>. The function verifies that:</p><ul><li>The number of identifiers does not exceed a predefined bulk limit (<code>BULK_LIMIT</code>).</li><li>The number of new embedding vectors matches the number of identifiers.</li><li>All provided embedding vectors have the same length.</li></ul><p>If the optional <code>data_type</code> is not provided, it is inferred from the first embedding vector using <code>infer_data_type</code>.</p><p>The updates are executed within a single SQLite transaction to ensure atomicity. For each identifier, the function:</p><ul><li>Converts the corresponding embedding vector to a JSON string using <code>to_json_embedding</code>.</li><li>Executes an UPDATE statement to set <code>embedding_json</code> and <code>data_type</code> for the row where <code>id_text</code> matches the identifier.</li></ul><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table containing the embeddings.</li><li><code>id_texts::Vector{&lt;:AbstractString}</code>: A vector of identifier strings corresponding to the rows to update.</li><li><code>new_embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}</code>: A vector of new embedding vectors. Every embedding must be of the same length.</li><li><code>data_type::Union{Nothing, String}=nothing</code>: Optional. A string representing the data type of the embeddings. If omitted, the data type is inferred from the first embedding.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> (&quot;true&quot;) if the update is successful.</li></ul><p><strong>Raises</strong></p><ul><li>An error if:<ul><li>The number of identifiers exceeds <code>BULK_LIMIT</code>.</li><li>There is a mismatch between the number of identifiers and the number of new embeddings.</li><li>The provided embedding vectors do not all have the same length.</li></ul></li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) ids = [&quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;] new<em>embs = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]] result = bulk</em>update<em>embedding(db, &quot;embeddings&quot;, ids, new</em>embs) println(&quot;Bulk update result: &quot;, result)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L859-L901">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.bulk_update_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}" href="#WunDeeDB.bulk_update_embedding-Tuple{String, String, Vector{&lt;:AbstractString}, Vector{&lt;:AbstractVector{&lt;:Number}}}"><code>WunDeeDB.bulk_update_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bulk<em>update</em>embedding(db<em>path::String, collection</em>name::String, id<em>texts::Vector{&lt;:AbstractString}, new</em>embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}; data_type::Union{Nothing,String}=nothing) -&gt; Union{String}</p><p>A convenience wrapper for performing a bulk update of embedding vectors using a database file path.</p><p>This function opens the SQLite database located at db<em>path and then calls the primary bulk</em>update_embedding function to update the embeddings for the specified identifiers in the given collection (table). The function ensures that the database connection is properly closed after the operation. In case an error occurs during the update, a descriptive error message is returned as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table containing the embeddings.</li><li>id_texts::Vector{&lt;:AbstractString}: A vector of identifier strings corresponding to the rows to update.</li><li>new_embeddings::Vector{&lt;:AbstractVector{&lt;:Number}}: A vector of new embedding vectors. All embeddings must be of the same length.</li><li>data_type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embeddings. If omitted, the data type is inferred from the first embedding.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String (&quot;true&quot;) indicating that the update was successful.</li><li>On error: A String containing the error message.</li></ul><p><strong>Example</strong></p><p>```julia result = bulk<em>update</em>embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, [&quot;id1&quot;, &quot;id2&quot;], [[1.0, 2.0], [3.0, 4.0]]) if startswith(result, &quot;Error:&quot;)     println(&quot;Bulk update failed: &quot;, result) else     println(&quot;Bulk update successful: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L937-L964">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.close_db-Tuple{SQLite.DB}" href="#WunDeeDB.close_db-Tuple{SQLite.DB}"><code>WunDeeDB.close_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>close_db(db::SQLite.DB)</p><p>Close an open SQLite database connection.</p><p>This function is a simple wrapper around SQLite.close to ensure that the provided database connection is properly closed when it is no longer needed.</p><p><strong>Arguments</strong></p><ul><li>db::SQLite.DB: The SQLite database connection to be closed.</li></ul><p><strong>Example</strong></p><p>```julia db = open_db(&quot;data/mydatabase.sqlite&quot;)</p><p><strong>Perform database operations...</strong></p><p>close_db(db)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L96-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.count_entries-Tuple{SQLite.DB, String}" href="#WunDeeDB.count_entries-Tuple{SQLite.DB, String}"><code>WunDeeDB.count_entries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>count<em>entries(db::SQLite.DB, collection</em>name::String; update_meta::Bool=false) -&gt; Int</p><p>Count the total number of entries (rows) in the specified collection (table) from an SQLite database, and optionally update the associated metadata table.</p><p>This function performs an SQL <code>COUNT(*)</code> query on the table named <code>collection_name</code> to obtain the number of rows. It retrieves the count from a result set containing a named tuple with the field <code>count</code>. Optionally, if the keyword argument <code>update_meta</code> is set to <code>true</code>, the function updates the metadata table, which is assumed to be named <code>$(collection_name)_meta</code>. The metadata update behavior is as follows:</p><ul><li><strong>If count &gt; 0:</strong> Update the <code>row_num</code> field with the current count.</li><li><strong>If count == 0:</strong> Clear the metadata by setting <code>row_num</code> to 0 and <code>vector_length</code> to <code>NULL</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An open connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table whose entries are to be counted.</li><li><code>update_meta::Bool=false</code>: Optional flag indicating whether to update the metadata table based on the count.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The number of entries (rows) in the specified table.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) num<em>entries = count</em>entries(db, &quot;embeddings&quot;; update<em>meta=true) println(&quot;Number of entries: &quot;, num</em>entries)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1432-L1458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.count_entries-Tuple{String, String}" href="#WunDeeDB.count_entries-Tuple{String, String}"><code>WunDeeDB.count_entries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>count<em>entries(db</em>path::String, collection<em>name::String; update</em>meta::Bool=false) -&gt; Union{Int, String}</p><p>A convenience wrapper for counting entries in a specified table of an SQLite database by using a file path. This function opens an SQLite database using db<em>path, delegates the counting to count</em>entries(db::SQLite.DB, collection<em>name; update</em>meta::Bool=false), and then ensures that the database connection is closed after the operation. In case an error occurs during the process, the function returns a descriptive error message as a string.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table whose entries are to be counted.</li><li>update_meta::Bool=false: Optional flag indicating whether to update the metadata table.</li></ul><p><strong>Returns</strong></p><ul><li>On success: An Int representing the number of entries in the table.</li><li>On error: A String containing the error message.</li></ul><p><strong>Example</strong></p><p>```julia result = count<em>entries(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;; update</em>meta=true) if isa(result, String)     println(&quot;Error occurred: &quot;, result) else     println(&quot;Number of entries: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1479-L1505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.delete_embedding-Tuple{SQLite.DB, String, Any}" href="#WunDeeDB.delete_embedding-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.delete_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>delete<em>embedding(db::SQLite.DB, collection</em>name::String, id_text) -&gt; String</p><p>Delete a single embedding record from the specified collection (table) in an SQLite database.</p><p>This function performs the following steps within a single SQLite transaction:</p><ol><li><p><strong>Record Existence Check:</strong>   It verifies that a record with the specified <code>id_text</code> exists in the table <code>collection_name</code> by executing a SELECT query.   If no matching record is found, an error with the message <code>&quot;notfound&quot;</code> is raised.</p></li><li><p><strong>Deletion:</strong>   If the record exists, the function deletes the corresponding row from the table using a DELETE SQL command.</p></li><li><p><strong>Metadata Update:</strong>   After deleting the record, it calls <code>update_meta_delete</code> on the associated metadata table (assumed to be named <code>$(collection_name)_meta</code>) to update any metadata related to the deletion.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>collection_name::String</code>: The name of the table from which the embedding record should be deleted.</li><li><code>id_text</code>: The identifier of the record to delete (this value is converted to a string for SQL operations).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> with the value <code>&quot;true&quot;</code> if the deletion (and metadata update) is successful.</li></ul><p><strong>Raises</strong></p><ul><li>An error with the message <code>&quot;notfound&quot;</code> if no record with the specified <code>id_text</code> exists.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) result = delete_embedding(db, &quot;embeddings&quot;, &quot;record123&quot;) if result == &quot;true&quot;     println(&quot;Record deleted successfully.&quot;) else     println(&quot;Deletion error: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L531-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.delete_embedding-Tuple{String, String, Any}" href="#WunDeeDB.delete_embedding-Tuple{String, String, Any}"><code>WunDeeDB.delete_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>delete<em>embedding(db</em>path::String, collection<em>name::String, id</em>text) -&gt; Union{String}</p><p>A convenience wrapper for deleting a single embedding record from an SQLite database by specifying the database file path.</p><p>This function opens the SQLite database at db<em>path, calls the primary delete</em>embedding function to delete the specified record, and then ensures that the database connection is properly closed. If an error occurs during deletion, a descriptive error message is returned as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table from which the record is to be deleted.</li><li>id_text: The identifier of the record to delete (converted to a string for SQL operations).</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String with the value &quot;true&quot; indicating the record was successfully deleted.</li><li>On error: A String containing a descriptive error message.</li></ul><p><strong>Example</strong></p><p>```julia result = delete_embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, &quot;record123&quot;) if startswith(result, &quot;Error:&quot;)     println(&quot;Deletion failed: &quot;, result) else     println(&quot;Record deleted successfully.&quot;) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L591-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_embedding-Tuple{SQLite.DB, String, Any}" href="#WunDeeDB.get_embedding-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>embedding(db::SQLite.DB, collection</em>name::String, id_text) -&gt; Union{Vector{T}, Nothing} where T</p><p>Retrieve the embedding vector for a given identifier from a specified collection (table) in an SQLite database.</p><p>This function queries the table <code>collection_name</code> for the row where the <code>id_text</code> matches the provided identifier (converted to a string). The table is expected to have two columns:</p><ul><li><code>embedding_json</code>: A JSON-encoded string representing the embedding vector.</li><li><code>data_type</code>: A string that specifies the type of the elements in the embedding vector.</li></ul><p>The JSON string is parsed into a Julia vector using <code>JSON3.read</code> with the element type determined by the helper function <code>parse_data_type</code>. If no matching row is found, the function returns <code>nothing</code>.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table (collection) to query.</li><li><code>id_text</code>: The identifier for which the embedding is requested (this value is converted to a string).</li></ul><p><strong>Returns</strong></p><ul><li>A vector representing the parsed embedding if a matching row is found.</li><li><code>nothing</code> if no row with the specified <code>id_text</code> exists.</li></ul><p><strong>Example</strong></p><p>```julia embedding = get_embedding(db, &quot;embeddings&quot;, &quot;id123&quot;) if embedding === nothing     println(&quot;No embedding found for the given id.&quot;) else     println(&quot;Retrieved embedding: &quot;, embedding) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L992-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_embedding-Tuple{String, String, Any}" href="#WunDeeDB.get_embedding-Tuple{String, String, Any}"><code>WunDeeDB.get_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>embedding(db</em>path::String, collection<em>name::String, id</em>text) -&gt; Union{Vector{T}, Nothing, String} where T</p><p>A convenience wrapper for retrieving an embedding vector from a specified SQLite database by using the database file path.</p><p>This function opens the SQLite database located at db<em>path, delegates the retrieval of the embedding to get</em>embedding(db::SQLite.DB, collection<em>name, id</em>text), and then ensures that the database connection is closed. In the event of an error during the operation, the function returns a descriptive error message as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table (collection) to query.</li><li>id_text: The identifier for which the embedding is requested (converted to a string).</li></ul><p><strong>Returns</strong></p><ul><li>On success: A vector representing the parsed embedding if found, or nothing if no matching row exists.</li><li>On error: A String containing an error message.</li></ul><p>Example ```julia embedding = get_embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, &quot;id123&quot;) if isa(embedding, String)     println(&quot;Error: &quot;, embedding) elseif embedding === nothing     println(&quot;No embedding found for the given id.&quot;) else     println(&quot;Retrieved embedding: &quot;, embedding) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1043-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_embedding_size-Tuple{SQLite.DB, String}" href="#WunDeeDB.get_embedding_size-Tuple{SQLite.DB, String}"><code>WunDeeDB.get_embedding_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>embedding</em>size(db::SQLite.DB, collection_name::String) -&gt; Int</p><p>Fetch the embedding vector size for a given collection from the metadata table in an SQLite database.</p><p>This function queries the metadata table associated with the collection, which is assumed to be named  <code>$(collection_name)_meta</code>, and retrieves the value of the <code>vector_length</code> column. If no metadata is found,  the function returns <code>0</code>; otherwise, it returns the embedding size from the first row of the query result.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The base name of the collection whose embedding size is to be retrieved. The metadata table is expected to be named as <code>$(collection_name)_meta</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The embedding vector size if metadata is found, or <code>0</code> if no metadata exists.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) embedding<em>size = get</em>embedding<em>size(db, &quot;embeddings&quot;) println(&quot;Embedding size: &quot;, embedding</em>size)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1520-L1542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_embedding_size-Tuple{String, String}" href="#WunDeeDB.get_embedding_size-Tuple{String, String}"><code>WunDeeDB.get_embedding_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>embedding</em>size(db<em>path::String, collection</em>name::String) -&gt; Union{Int, String}</p><p>A convenience wrapper for retrieving the embedding size from an SQLite database using a file path.</p><p>This function opens an SQLite database using the provided db<em>path and delegates the retrieval of the embedding size to get</em>embedding<em>size(db::SQLite.DB, collection</em>name). It ensures that the database connection is closed after the operation. If an error occurs during the process, the function returns a string with the error message.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection<em>name::String: The base name of the collection. The metadata table is expected to be named $(Expr(:incomplete, Base.Meta.ParseError(&quot;ParseError:\n# Error @ none:1:12\n(collection\n#          └ ── Expected `)`&quot;, Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(&quot;(collection&quot;, 0, &quot;none&quot;, 1, [1, 12]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(12, 11, :error, &quot;Expected `)`&quot;)], :other))))</em>name)_meta.</li></ul><p><strong>Returns</strong></p><ul><li>On success: An Int representing the embedding vector size.</li><li>On error: A String containing an error message.</li></ul><p><strong>Example</strong></p><p>```julia embedding<em>size = get</em>embedding<em>size(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;) if isa(embedding</em>size, String)     println(&quot;Error occurred: &quot;, embedding<em>size) else     println(&quot;Embedding size: &quot;, embedding</em>size) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1553-L1578">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_next_id-Tuple{SQLite.DB, String, Any}" href="#WunDeeDB.get_next_id-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_next_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>next</em>id(db::SQLite.DB, collection<em>name::String, current</em>id; full_row::Bool=false) -&gt; Union{Nothing, Any}</p><p>Retrieve the entry that immediately follows a given <code>current_id</code> in lexicographical (alphabetical) order from the specified collection (table) in an SQLite database.</p><p>This function searches for the row in <code>collection_name</code> where the <code>id_text</code> is lexicographically greater than <code>current_id</code>. The SQL query uses the condition <code>WHERE id_text &gt; ?</code> and orders the results in ascending lexicographical order (<code>ORDER BY id_text ASC</code>), ensuring that the smallest <code>id_text</code> greater than <code>current_id</code> is returned.</p><ul><li><strong>When <code>full_row</code> is <code>false</code> (default):</strong>   Only the <code>id_text</code> of the next entry is returned.</li><li><strong>When <code>full_row</code> is <code>true</code>:</strong>   The function returns a NamedTuple containing:<ul><li><code>id_text</code>: The identifier of the entry.</li><li><code>embedding</code>: The embedding vector parsed from the JSON string found in the <code>embedding_json</code> field.</li><li><code>data_type</code>: The data type indicator used for parsing the embedding (with the appropriate type determined by <code>parse_data_type</code>).</li></ul></li></ul><p>If no such entry is found (i.e., there is no row with an <code>id_text</code> lexicographically greater than <code>current_id</code>), the function returns <code>nothing</code>.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table (collection) to query.</li><li><code>current_id</code>: The current identifier for comparison (expected to be a string or a type compatible with lexicographical ordering).</li><li><code>full_row::Bool=false</code>: Optional flag. Set to <code>true</code> to retrieve the full row (with parsed embedding); otherwise, only the <code>id_text</code> is returned.</li></ul><p><strong>Returns</strong></p><ul><li>If a next entry is found:<ul><li><strong>Default (<code>full_row == false</code>):</strong> Returns the <code>id_text</code> of the next entry.</li><li><strong>If <code>full_row == true</code>:</strong> Returns a NamedTuple with fields <code>id_text</code>, <code>embedding</code>, and <code>data_type</code>.</li></ul></li><li>If no entry is found: Returns <code>nothing</code>.</li></ul><p><strong>Example</strong></p><p>```julia</p><p><strong>Retrieve only the next id based on lexicographical ordering:</strong></p><p>next<em>id = get</em>next<em>id(db, &quot;embeddings&quot;, current</em>id) println(&quot;Next ID (lexicographical): &quot;, next_id)</p><p><strong>Retrieve the full next row with parsed embedding:</strong></p><p>next<em>row = get</em>next<em>id(db, &quot;embeddings&quot;, current</em>id; full<em>row=true) if next</em>row !== nothing     @show next<em>row.id</em>text, next<em>row.embedding, next</em>row.data_type else     println(&quot;No next entry found based on lexicographical ordering.&quot;) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1184-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_next_id-Tuple{String, String, Any}" href="#WunDeeDB.get_next_id-Tuple{String, String, Any}"><code>WunDeeDB.get_next_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>next</em>id(db<em>path::String, collection</em>name::String, current<em>id; full</em>row::Bool=false) -&gt; Union{Nothing, Any, String}</p><p>A convenience wrapper for retrieving the entry that immediately follows a given current_id (based on lexicographical ordering) from a specified collection using a database file path.</p><p>This function opens an SQLite database using the provided db<em>path and delegates the retrieval of the next entry to get</em>next<em>id(db::SQLite.DB, collection</em>name, current<em>id; full</em>row::Bool=false). The lexicographical comparison (WHERE id<em>text &gt; ?) ensures that the smallest id</em>text greater than current_id is returned. The database connection is closed after the operation, and any errors encountered are returned as a descriptive string. Arguments</p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table (collection) to query.</li><li>current_id: The current identifier used for comparison.</li><li>full<em>row::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding); otherwise, only the id</em>text is returned.</li></ul><p><strong>Returns</strong></p><ul><li>On success:<ul><li>If a next entry is found:<ul><li>Default (full<em>row == false): Returns the id</em>text of the next entry.</li><li>If full<em>row == true): Returns a NamedTuple with fields id</em>text, embedding, and data_type.</li></ul></li><li>If no entry is found: Returns nothing.</li></ul></li><li>On error: Returns a String containing the error message.</li></ul><p><strong>Example</strong></p><p>```julia result = get<em>next</em>id(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, current<em>id; full</em>row=true) if isa(result, String)     println(&quot;Error: &quot;, result) elseif result === nothing     println(&quot;No next entry found based on lexicographical ordering.&quot;) else     @show result.id<em>text, result.embedding, result.data</em>type end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1262-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_previous_id-Tuple{SQLite.DB, String, Any}" href="#WunDeeDB.get_previous_id-Tuple{SQLite.DB, String, Any}"><code>WunDeeDB.get_previous_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>previous</em>id(db::SQLite.DB, collection<em>name::String, current</em>id; full_row::Bool=false) -&gt; Union{Nothing, Any}</p><p>Retrieve the entry that immediately precedes a given <code>current_id</code> in lexicographical (alphabetical) order from the specified collection (table) in an SQLite database.</p><p>This function searches for the row in <code>collection_name</code> where the <code>id_text</code> is lexicographically less than <code>current_id</code>. The comparison is performed using standard string ordering (i.e., alphabetical order), so it is assumed that the <code>id_text</code> values are stored as strings. The query orders the results in descending lexicographical order by <code>id_text</code>, ensuring that the row with the closest preceding <code>id_text</code> is selected.</p><ul><li><p><strong>When <code>full_row</code> is <code>false</code> (default):</strong>   The function returns only the <code>id_text</code> of the previous entry.</p></li><li><p><strong>When <code>full_row</code> is <code>true</code>:</strong>   The function returns a NamedTuple containing:</p><ul><li><code>id_text</code>: The identifier of the entry.</li><li><code>embedding</code>: The embedding vector parsed from the JSON string in the <code>embedding_json</code> field.</li><li><code>data_type</code>: The data type indicator used to parse the embedding (with the type determined by <code>parse_data_type</code>).</li></ul></li></ul><p>If no entry is found (i.e., there is no row with an <code>id_text</code> lexicographically less than <code>current_id</code>), the function returns <code>nothing</code>.</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table (collection) to query.</li><li><code>current_id</code>: The current identifier used for comparison (expected to be a string or compatible type).</li><li><code>full_row::Bool=false</code>: Optional flag. Set to <code>true</code> to retrieve the full row (with parsed embedding), or <code>false</code> to retrieve only the <code>id_text</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If a previous entry is found:<ul><li><strong>Default (<code>full_row == false</code>):</strong> Returns the <code>id_text</code> of the previous entry.</li><li><strong>If <code>full_row == true</code>:</strong> Returns a NamedTuple with fields <code>id_text</code>, <code>embedding</code>, and <code>data_type</code>.</li></ul></li><li>If no previous entry is found: Returns <code>nothing</code>.</li></ul><p><strong>Example</strong></p><p>```julia</p><p><strong>Retrieve only the previous id based on lexicographical ordering:</strong></p><p>prev<em>id = get</em>previous<em>id(db, &quot;embeddings&quot;, current</em>id) println(&quot;Previous ID (lexicographical): &quot;, prev_id)</p><p><strong>Retrieve the full previous row with parsed embedding:</strong></p><p>prev<em>row = get</em>previous<em>id(db, &quot;embeddings&quot;, current</em>id; full<em>row=true) if prev</em>row !== nothing     @show prev<em>row.id</em>text, prev<em>row.embedding, prev</em>row.data_type else     println(&quot;No previous entry found based on lexicographical ordering.&quot;) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1307-L1350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.get_previous_id-Tuple{String, String, Any}" href="#WunDeeDB.get_previous_id-Tuple{String, String, Any}"><code>WunDeeDB.get_previous_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>previous</em>id(db<em>path::String, collection</em>name::String, current<em>id; full</em>row::Bool=false) -&gt; Union{Nothing, Any, String}</p><p>A convenience wrapper for retrieving the entry immediately preceding a given current_id (based on lexicographical ordering) from a collection by specifying the database file path.</p><p>This function opens an SQLite database using the provided db<em>path and delegates the task to get</em>previous<em>id(db::SQLite.DB, collection</em>name, current<em>id; full</em>row::Bool=false). The comparison of id_text values is performed lexicographically (alphabetically), ensuring that the row with the closest preceding identifier is selected. The database connection is properly closed after the operation. In the event of an error, the function returns a descriptive error message as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table (collection) to query.</li><li>current_id: The current identifier used for comparison (expected to be a string or a compatible type).</li><li>full<em>row::Bool=false: Optional flag. Set to true to retrieve the full row (with parsed embedding), or false to retrieve only the id</em>text.</li></ul><p><strong>Returns</strong></p><ul><li>On success:<ul><li>If a previous entry is found:<ul><li>Default (full<em>row == false): Returns the id</em>text of the previous entry.</li><li>If full<em>row == true: Returns a NamedTuple with fields id</em>text, embedding, and data_type.</li></ul></li><li>If no previous entry is found: Returns nothing.</li></ul></li><li>On error: Returns a String containing the error message.</li></ul><p><strong>Example</strong></p><p>```julia result = get<em>previous</em>id(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, current<em>id; full</em>row=true) if isa(result, String)     println(&quot;Error: &quot;, result) elseif result === nothing     println(&quot;No previous entry found based on lexicographical ordering.&quot;) else     @show result.id<em>text, result.embedding, result.data</em>type end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1384-L1418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.initialize_db-Tuple{String, String}" href="#WunDeeDB.initialize_db-Tuple{String, String}"><code>WunDeeDB.initialize_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>initialize<em>db(db</em>path::String, collection_name::String) -&gt; String</p><p>Initialize an SQLite database for storing embedding records and corresponding metadata.</p><p>This function performs the following operations:</p><ol><li>Opens the SQLite database located at <code>db_path</code>.</li><li>Configures the database for improved write performance by setting:<ul><li><code>journal_mode</code> to <code>WAL</code> (Write-Ahead Logging).</li><li><code>synchronous</code> to <code>NORMAL</code>.</li></ul></li><li>Creates the main table for storing embeddings if it does not already exist. The table is named as specified by <code>collection_name</code> and includes:<ul><li><code>id_text</code> (TEXT PRIMARY KEY): A unique identifier for each embedding record.</li><li><code>embedding_json</code> (TEXT NOT NULL): The JSON-encoded embedding vector.</li><li><code>data_type</code> (TEXT): A column to store information about the data type of the embedding.</li></ul></li><li>Creates a metadata table (named <code>$(collection_name)_meta</code>) if it does not already exist. This table stores:<ul><li><code>row_num</code> (BIGINT): The number of embedding records.</li><li><code>vector_length</code> (INT): The length of the embedding vectors.</li></ul></li></ol><p>After performing these steps, the function closes the database connection. On successful initialization, it returns <code>&quot;true&quot;</code>.   If an error occurs during the process, the function ensures that the database is closed and returns an error message string.</p><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: The file path to the SQLite database.</li><li><code>collection_name::String</code>: The base name for the main collection table. The associated metadata table will be named as <code>$(collection_name)_meta</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code>:<ul><li><code>&quot;true&quot;</code> if the database is successfully initialized.</li><li>A descriptive error message if an error occurs.</li></ul></li></ul><p><strong>Example</strong></p><p>```julia result = initialize_db(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;) if result == &quot;true&quot;     println(&quot;Database initialized successfully.&quot;) else     println(&quot;Database initialization failed: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L119-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.insert_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}" href="#WunDeeDB.insert_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.insert_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>insert<em>embedding(db::SQLite.DB, collection</em>name::String, id<em>text, embedding::AbstractVector{&lt;:Number};                       data</em>type::Union{Nothing,String}=nothing) -&gt; String</p><p>Insert a single embedding record into the specified collection (table) within an SQLite database.</p><p>This function performs the following steps:</p><ol><li><p><strong>Data Type Handling:</strong>   If <code>data_type</code> is not provided, it is inferred from the embedding using <code>infer_data_type(embedding)</code>.</p></li><li><p><strong>Embedding Conversion:</strong>   The embedding vector is converted to a JSON string using <code>to_json_embedding(embedding)</code>.</p></li><li><p><strong>Atomic Insertion and Metadata Update:</strong>   The insertion of the record and the subsequent update of the associated metadata table (named <code>$(collection_name)_meta</code>) are performed within a single SQLite transaction.   The metadata is updated via <code>update_meta(db, &quot;$(collection_name)_meta&quot;, length(embedding))</code>, which records the dimension of the embedding.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active SQLite database connection.</li><li><code>collection_name::String</code>: The name of the table where the embedding record is stored.</li><li><code>id_text</code>: The unique identifier for the record (converted to a string for the query).</li><li><code>embedding::AbstractVector{&lt;:Number}</code>: The embedding vector to be inserted.</li><li><code>data_type::Union{Nothing,String}=nothing</code>: Optional. A string specifying the data type of the embedding values. If not provided, the data type is inferred from the embedding.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> with the value <code>&quot;true&quot;</code> indicating a successful insertion.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) id = &quot;record123&quot; emb = [0.1, 0.2, 0.3, 0.4] result = insert_embedding(db, &quot;embeddings&quot;, id, emb) println(&quot;Insert result: &quot;, result)  # Expected output: &quot;true&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L302-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.insert_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}" href="#WunDeeDB.insert_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.insert_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>insert<em>embedding(db</em>path::String, collection<em>name::String, id</em>text, embedding::AbstractVector{&lt;:Number}; data_type::Union{Nothing,String}=nothing) -&gt; Union{String}</p><p>A convenience wrapper for inserting a single embedding record into an SQLite database by specifying the database file path.</p><p>This function:</p><ul><li>Opens the SQLite database at the given db_path.</li><li>Delegates the record insertion to insert<em>embedding(db, collection</em>name, id<em>text, embedding; data</em>type=data_type).</li><li>Ensures that the database connection is closed after the operation.</li><li>Returns a descriptive error message if an exception occurs.</li></ul><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table where the embedding will be inserted.</li><li>id_text: The unique identifier for the record (converted to a string for the query).</li><li>embedding::AbstractVector{&lt;:Number}: The embedding vector to be inserted.</li><li>data_type::Union{Nothing,String}=nothing: Optional. A string specifying the data type of the embedding values. If omitted, the data type is inferred from the embedding.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String with the value &quot;true&quot;.</li><li>On error: A String containing a descriptive error message.</li></ul><p><strong>Example</strong></p><p>```julia result = insert_embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, &quot;record123&quot;, [0.1, 0.2, 0.3, 0.4]) if startswith(result, &quot;Error:&quot;)     println(&quot;Insert failed: &quot;, result) else     println(&quot;Record inserted successfully.&quot;) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L355-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.open_db-Tuple{String}" href="#WunDeeDB.open_db-Tuple{String}"><code>WunDeeDB.open_db</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>open<em>db(db</em>path::String) -&gt; SQLite.DB</p><p>Open an SQLite database located at the specified file path, ensuring that the directory exists.</p><p>This function performs the following steps:</p><ol><li><p><strong>Directory Check and Creation:</strong>   It determines the directory path for <code>db_path</code> and checks whether it exists. If the directory does not exist, the function attempts to create it using <code>mkpath</code>.   If directory creation fails, an error is raised with a descriptive message.</p></li><li><p><strong>Database Connection and Configuration:</strong>   The function opens an SQLite database connection using <code>SQLite.DB(db_path)</code>.   It then sets two PRAGMA options for improved write performance:</p><ul><li><code>journal_mode</code> is set to <code>WAL</code> (Write-Ahead Logging).</li><li><code>synchronous</code> is set to <code>NORMAL</code>.</li></ul></li><li><p><strong>Return Value:</strong>   The configured SQLite database connection is returned.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>db_path::String</code>: The file path to the SQLite database. The function will ensure that the directory containing this file exists.</li></ul><p><strong>Returns</strong></p><ul><li>An instance of <code>SQLite.DB</code> representing the open and configured database connection.</li></ul><p><strong>Example</strong></p><p>```julia db = open_db(&quot;data/mydatabase.sqlite&quot;)</p><p><strong>Use the database connection...</strong></p><p>SQLite.execute(db, &quot;SELECT * FROM my_table;&quot;)</p><p><strong>Don&#39;t forget to close the database when done.</strong></p><p>close_db(db)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L45-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.random_embeddings-Tuple{SQLite.DB, String, Int64}" href="#WunDeeDB.random_embeddings-Tuple{SQLite.DB, String, Int64}"><code>WunDeeDB.random_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>random<em>embeddings(db::SQLite.DB, collection</em>name::String, num::Int) -&gt; Vector{Dict{String,Any}}</p><p>Retrieve a specified number of random embedding records from a given collection in an SQLite database.</p><p>This function performs an SQL query against the specified <code>collection_name</code> (which is typically the name of a table in the database) to fetch up to <code>num</code> random rows. Each row is expected to have the following columns:</p><ul><li><code>id_text</code>: An identifier for the embedding.</li><li><code>embedding_json</code>: A JSON string representing the embedding vector.</li><li><code>data_type</code>: A string indicating the data type of the elements within the embedding.</li></ul><p>The JSON in <code>embedding_json</code> is parsed using JSON3 into a <code>Vector{T}</code>, where the type <code>T</code> is determined by the <code>data_type</code> field (via the helper function <code>parse_data_type</code>).</p><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table/collection from which to retrieve embeddings.</li><li><code>num::Int</code>: The number of random embeddings to retrieve. This value must be between 1 and <code>BULK_LIMIT</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Vector{Dict{String, Any}}</code> where each dictionary has the following keys:</p><ul><li><code>&quot;id_text&quot;</code>: The unique identifier for the embedding.</li><li><code>&quot;embedding&quot;</code>: The embedding vector (parsed from JSON).</li><li><code>&quot;data_type&quot;</code>: The data type string that was used to parse the embedding.</li></ul><p><strong>Throws</strong></p><ul><li>Raises an error if <code>num</code> is less than 1 or greater than <code>BULK_LIMIT</code>.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) embeddings = random<em>embeddings(db, &quot;embeddings</em>table&quot;, 5) for record in embeddings     @show record[&quot;id<em>text&quot;], record[&quot;embedding&quot;], record[&quot;data</em>type&quot;] end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1592-L1628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.random_embeddings-Tuple{String, String, Int64}" href="#WunDeeDB.random_embeddings-Tuple{String, String, Int64}"><code>WunDeeDB.random_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>random<em>embeddings(db</em>path::String, collection_name::String, num::Int) -&gt; Union{Vector{Dict{String,Any}}, String}</p><p>A convenience wrapper to retrieve random embedding records by providing a database file path.</p><p>This function opens an SQLite database using the file path db<em>path, then delegates the task of fetching random embeddings to the random</em>embeddings(db::SQLite.DB, collection_name, num) function. Once the data has been retrieved (or an error occurs), the database connection is properly closed. In the event of an exception during retrieval, the function returns a string that describes the error.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table/collection from which to retrieve embeddings.</li><li>num::Int: The number of random embeddings to retrieve. This value must be between 1 and BULK_LIMIT.</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">On success: A Vector{Dict{String, Any}} where each dictionary contains keys &quot;id_text&quot;, &quot;embedding&quot;, and &quot;data_type&quot;.
On failure: A String containing an error message.</code></pre><p><strong>Example</strong></p><p>result = random<em>embeddings(&quot;mydatabase.sqlite&quot;, &quot;embeddings</em>table&quot;, 5) if typeof(result) == String     println(&quot;An error occurred: &quot;, result) else     for record in result         @show record[&quot;id<em>text&quot;], record[&quot;embedding&quot;], record[&quot;data</em>type&quot;]     end end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L1653-L1681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.update_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}" href="#WunDeeDB.update_embedding-Tuple{SQLite.DB, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.update_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>update<em>embedding(db::SQLite.DB, collection</em>name::String, id<em>text, new</em>embedding::AbstractVector{&lt;:Number};                      data_type::Union{Nothing,String}=nothing) -&gt; String</p><p>Update the embedding vector for a specified record in the given collection (table) within an SQLite database.</p><p>This function performs several key steps within a single SQLite transaction:</p><ol><li><p><strong>Record Existence Check:</strong>   It first verifies that a record with the given <code>id_text</code> exists in the table <code>collection_name</code>.   If no record is found, the function raises an error with the message <code>&quot;notfound&quot;</code>.</p></li><li><p><strong>Metadata Retrieval and Dimension Validation:</strong>   The function retrieves metadata from the associated metadata table (named as <code>$(collection_name)_meta</code>) to obtain the stored embedding vector length (<code>vector_length</code>).   If the metadata is missing, an error is raised indicating that no metadata was found.   It then compares the stored length with the length of the new embedding vector (<code>new_embedding</code>).   If the lengths do not match, an error is raised with details about the mismatch.</p></li><li><p><strong>Embedding Conversion and Data Type Determination:</strong>   The new embedding vector is converted to a JSON string using <code>to_json_embedding</code>.   If the optional <code>data_type</code> parameter is not provided, it is inferred from the new embedding using <code>infer_data_type</code>.</p></li><li><p><strong>Record Update:</strong>   Finally, the function updates the record in the table <code>collection_name</code> by setting the <code>embedding_json</code> and <code>data_type</code> fields for the row where <code>id_text</code> matches the provided identifier.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>db::SQLite.DB</code>: An active connection to an SQLite database.</li><li><code>collection_name::String</code>: The name of the table containing the embeddings.</li><li><code>id_text</code>: The identifier of the record to update (converted to a string for the query).</li><li><code>new_embedding::AbstractVector{&lt;:Number}</code>: The new embedding vector to be stored.</li><li><code>data_type::Union{Nothing, String}=nothing</code>: Optional. A string representing the data type of the embedding values. If not provided, the data type is inferred from <code>new_embedding</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>String</code> with the value <code>&quot;true&quot;</code> indicating a successful update.</li></ul><p><strong>Raises</strong></p><ul><li><code>&quot;notfound&quot;</code>: If no record with the specified <code>id_text</code> exists in <code>collection_name</code>.</li><li>An error if no metadata is found in the associated metadata table.</li><li>An error if the new embedding&#39;s length does not match the stored <code>vector_length</code>.</li></ul><p><strong>Example</strong></p><p>```julia db = SQLite.DB(&quot;mydatabase.sqlite&quot;) id = &quot;record123&quot; new<em>vec = [0.1, 0.2, 0.3, 0.4] result = update</em>embedding(db, &quot;embeddings&quot;, id, new_vec) if result == &quot;true&quot;     println(&quot;Embedding updated successfully.&quot;) else     println(&quot;Update failed: &quot;, result) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L723-L773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WunDeeDB.update_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}" href="#WunDeeDB.update_embedding-Tuple{String, String, Any, AbstractVector{&lt;:Number}}"><code>WunDeeDB.update_embedding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>update<em>embedding(db</em>path::String, collection<em>name::String, id</em>text, new<em>embedding::AbstractVector{&lt;:Number}; data</em>type::Union{Nothing,String}=nothing) -&gt; Union{String}</p><p>A convenience wrapper for updating an embedding vector using a database file path.</p><p>This function opens the SQLite database specified by db<em>path and then calls the primary update</em>embedding function to update the embedding for the specified record in the collection (table). It ensures that the database connection is properly closed after the operation. If an error occurs during the update, a descriptive error message is returned as a String.</p><p><strong>Arguments</strong></p><ul><li>db_path::String: The file path to the SQLite database.</li><li>collection_name::String: The name of the table containing the embeddings.</li><li>id_text: The identifier of the record to update.</li><li>new_embedding::AbstractVector{&lt;:Number}: The new embedding vector to be stored.</li><li>data<em>type::Union{Nothing, String}=nothing: Optional. A string representing the data type of the embedding values. If omitted, it is inferred from new</em>embedding.</li></ul><p><strong>Returns</strong></p><ul><li>On success: A String with the value &quot;true&quot;.</li><li>On error: A String containing a descriptive error message.</li></ul><p><strong>Example</strong></p><p>```julia result = update_embedding(&quot;mydatabase.sqlite&quot;, &quot;embeddings&quot;, &quot;record123&quot;, [0.1, 0.2, 0.3, 0.4]) if startswith(result, &quot;Error:&quot;)     println(&quot;Update failed: &quot;, result) else     println(&quot;Embedding updated successfully.&quot;) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mantzaris/WunDeeDB.jl/blob/54cf94615fac8bb8419e814165e5f85da42bfc61/src/WunDeeDB.jl#L817-L844">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 17 February 2025 01:41">Monday 17 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
